# Pizza Backend API 설계도

## 프로젝트 개요
- **프로젝트명**: pizza_back
- **프레임워크**: Django 5.2.5 + Django REST Framework
- **데이터베이스**: PostgreSQL
- **인증**: JWT (JSON Web Token)
- **CORS**: 모든 오리진 허용

## 주요 기능
1. **사용자 인증 및 관리**
2. **피자 메뉴 관리**
3. **주문 처리 및 관리**

## 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                    Client (Frontend)                        │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP/HTTPS
                      │ JWT Token
┌─────────────────────▼───────────────────────────────────────┐
│                 Django Backend                              │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                URL Router                                ││
│  │  /api/login/     /api/menu/     /api/order/            ││
│  └─────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────┐│
│  │                Middleware Stack                         ││
│  │  CORS → Security → Session → Auth → Messages           ││
│  └─────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────┐│
│  │                Application Layer                         ││
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐                 ││
│  │  │  Login  │  │  Menu   │  │  Order  │                 ││
│  │  │   App   │  │   App   │  │   App   │                 ││
│  │  └─────────┘  └─────────┘  └─────────┘                 ││
│  └─────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────┐│
│  │                Database Layer                           ││
│  │              PostgreSQL Database                        ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

## 데이터베이스 설계

### 1. Member 테이블 (사용자)
```sql
CREATE TABLE member (
    member_id VARCHAR(100) PRIMARY KEY,
    member_pwd VARCHAR(100) NOT NULL,
    member_nm VARCHAR(100) NOT NULL
);
```

### 2. PizzaType 테이블 (피자 종류)
```sql
CREATE TABLE pizza_types (
    pizza_type_id VARCHAR(50) PRIMARY KEY,
    pizza_nm VARCHAR(50) NOT NULL,
    pizza_categ VARCHAR(50) NOT NULL,
    pizza_img_url VARCHAR(100) NOT NULL
);
```

### 3. Pizza 테이블 (피자 상품)
```sql
CREATE TABLE pizza (
    pizza_id VARCHAR(50) PRIMARY KEY,
    pizza_type_id VARCHAR(50) REFERENCES pizza_types(pizza_type_id),
    size VARCHAR(50) NOT NULL,
    price FLOAT NOT NULL
);
```

### 4. Branch 테이블 (지점)
```sql
CREATE TABLE branch (
    bran_id VARCHAR(100) PRIMARY KEY,
    bran_nm VARCHAR(100) NOT NULL
);
```

### 5. Order 테이블 (주문)
```sql
CREATE TABLE orders (
    order_id VARCHAR(50) PRIMARY KEY,
    member_id VARCHAR(50) NOT NULL,
    bran_id VARCHAR(100) REFERENCES branch(bran_id),
    date VARCHAR(50) NOT NULL,
    time VARCHAR(50) NOT NULL
);
```

### 6. OrderDetail 테이블 (주문 상세)
```sql
CREATE TABLE order_detail (
    order_detail_id INTEGER PRIMARY KEY,
    order_id VARCHAR(50) REFERENCES orders(order_id),
    pizza_id VARCHAR(50) REFERENCES pizza(pizza_id),
    quantity INTEGER NOT NULL
);
```

## API 엔드포인트

### 1. Login App (`/api/login/`)
| Method | Endpoint | 기능 | 인증 필요 |
|--------|----------|------|-----------|
| POST | `/login/` | 로그인 (JWT 토큰 발급) | ❌ |
| GET | `/login/logout/` | 로그아웃 | ❌ |
| POST | `/login/register/` | 회원가입 | ❌ |

### 2. Menu App (`/api/menu/`)
| Method | Endpoint | 기능 | 인증 필요 |
|--------|----------|------|-----------|
| GET | `/menu/` | 피자 목록 조회 | ❌ |
| GET | `/menu/types/` | 피자 종류 조회 | ❌ |
| POST | `/menu/get_pizza_id/` | 피자 ID 조회 | ❌ |

### 3. Order App (`/api/order/`)
| Method | Endpoint | 기능 | 인증 필요 |
|--------|----------|------|-----------|
| GET | `/order/myorder/` | 내 주문 목록 조회 | ✅ |
| POST | `/order/` | 새 주문 생성 | ✅ |
| GET | `/order/branch/` | 지점 목록 조회 | ❌ |

## 인증 시스템

### JWT 토큰 구조
```json
{
  "member_id": "사용자ID",
  "exp": "만료시간",
  "iat": "발급시간"
}
```

### 인증 플로우
1. 클라이언트가 로그인 요청 (`POST /api/login/`)
2. 서버가 유효한 사용자인지 확인
3. JWT 토큰 생성 및 반환
4. 클라이언트가 이후 요청에 `Authorization: Bearer <token>` 헤더 포함
5. 서버가 토큰 검증 후 요청 처리

## 주요 비즈니스 로직

### 1. 주문 처리 플로우
1. 사용자 인증 확인
2. 주문 데이터 유효성 검사
3. 피자 ID 조회 (외부 API 호출)
4. 주문 및 주문 상세 정보 생성
5. 트랜잭션으로 데이터 일관성 보장

### 2. 피자 ID 조회 로직
- 피자 이름과 사이즈로 피자 타입 ID 조회
- 피자 타입 ID와 사이즈로 최종 피자 ID 조회
- 외부 API를 통한 실시간 피자 정보 확인

## 보안 고려사항

### 현재 구현된 보안 기능
- JWT 기반 인증
- CORS 설정
- CSRF 보호 (일부 엔드포인트에서 제외)

### 개선 필요 사항
- 비밀번호 해싱 (현재 평문 저장)
- 입력 데이터 검증 강화
- SQL 인젝션 방지
- Rate Limiting 구현

## 기술 스택

### Backend
- Django 5.2.5
- Django REST Framework
- PostgreSQL
- JWT (PyJWT)
- CORS Headers

### 개발 환경
- Python Virtual Environment
- Django Admin Interface
- SQLite (개발용, 실제 운영은 PostgreSQL)

## 배포 및 운영

### 환경 설정
- `DEBUG = True` (개발 모드)
- `ALLOWED_HOSTS = []` (모든 호스트 허용)
- PostgreSQL 연결 설정 완료
- CORS 모든 오리진 허용

### API 기본 URL
- 개발 환경: `http://localhost:8000/api`

## 테스트 계획

### 테스트 전략
- **단위 테스트**: 각 모델, 뷰, 유틸리티 함수별 테스트
- **통합 테스트**: API 엔드포인트 전체 플로우 테스트
- **인증 테스트**: JWT 토큰 기반 인증 시스템 테스트
- **데이터베이스 테스트**: 모델 관계 및 데이터 무결성 테스트

### 테스트 범위

#### 1. Login App 테스트
- **회원가입 테스트**
  - 정상적인 회원가입
  - 중복 ID 처리
  - 필수 필드 누락 처리
  - 잘못된 JSON 형식 처리

- **로그인 테스트**
  - 정상적인 로그인
  - 잘못된 자격증명 처리
  - JWT 토큰 생성 및 검증
  - 토큰 만료 처리

- **로그아웃 테스트**
  - 로그아웃 응답 확인

#### 2. Menu App 테스트
- **피자 목록 조회 테스트**
  - 전체 피자 목록 반환
  - 빈 데이터베이스 처리

- **피자 종류 조회 테스트**
  - 피자 타입 목록 반환
  - 이미지 URL 포함 확인

- **피자 ID 조회 테스트**
  - 정상적인 피자 ID 조회
  - 존재하지 않는 피자 처리
  - 잘못된 사이즈 처리

#### 3. Order App 테스트
- **주문 생성 테스트**
  - 정상적인 주문 생성
  - 인증되지 않은 사용자 처리
  - 잘못된 주문 데이터 처리
  - 트랜잭션 롤백 테스트

- **주문 내역 조회 테스트**
  - 사용자별 주문 내역 조회
  - 빈 주문 내역 처리
  - 인증되지 않은 접근 처리

- **지점 조회 테스트**
  - 전체 지점 목록 반환
  - 빈 지점 데이터 처리

#### 4. 인증 시스템 테스트
- **JWT 토큰 테스트**
  - 토큰 생성 및 검증
  - 토큰 만료 처리
  - 잘못된 토큰 처리
  - Authorization 헤더 누락 처리

#### 5. 데이터베이스 테스트
- **모델 관계 테스트**
  - 외래키 관계 확인
  - CASCADE 삭제 동작
  - 데이터 무결성 확인

### 테스트 데이터
- 테스트용 사용자 계정
- 샘플 피자 데이터
- 샘플 지점 데이터
- 테스트용 주문 데이터

### 테스트 실행 방법
```bash
# 전체 테스트 실행
python manage.py test

# 특정 앱 테스트 실행
python manage.py test pizza_back.login
python manage.py test pizza_back.menu
python manage.py test pizza_back.order

# 특정 테스트 클래스 실행
python manage.py test pizza_back.login.tests.LoginTestCase

# 커버리지 리포트 생성
coverage run --source='.' manage.py test
coverage report
coverage html
```

## Kubernetes 마이크로서비스 분리 설계 (login/menu/order)

### 목표
- **도메인별 서비스 분리**: `login`, `menu`, `order` 3개 서비스로 독립 배포/스케일링.
- **공유 단일 DB 유지**: 물리 DB는 하나(PostgreSQL)로 유지하되, 테이블 논리 소유권만 분리.
- **k8s 네이티브 운영**: ConfigMap/Secret, HPA, Liveness/Readiness Probe, Service/Ingress 적용.
- **점진적 마이그레이션**: 어플리케이션만 분리, 데이터 이관 없이 진행.

### 상위 아키텍처

```
┌──────────────────────────────────────────────────────────────┐
│                        Ingress / API GW                       │
│                 (/login, /menu, /order 라우팅)               │
└───────────────┬───────────────────┬───────────────────────────┘
                │                   │
       ┌────────▼────────┐  ┌───────▼────────┐   ┌──────────────▼───────┐
       │ login-service    │  │ menu-service   │   │ order-service         │
       │ (auth, members)  │  │ (catalog)      │   │ (orders, branches)    │
       └────────┬─────────┘  └───────┬────────┘   └──────────────┬───────┘
                │                    │                           │
                └──────────────┬─────┴──────────────┬────────────┘
                               ▼                    ▼
                         ┌────────────────────────────────┐
                         │     Shared PostgreSQL (단일)   │
                         │  - member, pizza_types, pizza  │
                         │  - orders, order_detail, branch│
                         └────────────────────────────────┘
```

### 네임스페이스 및 리소스 네이밍 가이드
- Namespace: `pizza-prod`, `pizza-stg`, `pizza-dev`.
- Deploy/Service/ConfigMap/Secret: `{svc}-{env}` 패턴. 예) `login-deploy`, `menu-svc`.
- 이미지 태그: `{branch}-{shortsha}` 또는 SemVer. 예) `menu:1.2.0`.

---

### 1) login-service (인증/회원)
- **책임**: 회원 관리, 인증(JWT 발급/검증), 비밀번호 해싱
- **데이터 논리 소유**: 단일 DB 내 `member` 테이블에 대한 변경/스키마 관리 권한.
- **외부 노출 API (Ingress 경유)**
  - `POST /login/` 로그인 → JWT 발급
  - `GET /login/logout/` 로그아웃
  - `POST /login/register/` 회원가입
- **내부 제공 (서비스 간)**
  - `POST /int/auth/verify` 토큰 검증 
- **보안**
  - 비밀번호 해싱(Argon2/bcrypt).
  - JWT 서명키를 k8s Secret로 주입(`JWT_SECRET`).
- **k8s**
  - Env: `JWT_SECRET`, `DB_HOST/PORT/NAME/USER/PASSWORD`, `LOG_LEVEL`.
  - Probe: `/healthz` (readiness), `/livez` (liveness).
  - HPA: CPU/메모리 기반 오토스케일.

### 2) menu-service (카탈로그)
- **책임**: 피자 타입/상품/이미지/가격 조회. 캐시/검색 최적화.
- **데이터 논리 소유**: 단일 DB 내 `pizza_types`, `pizza` 테이블 변경/스키마 관리 권한.
- **외부 노출 API**
  - `GET /menu/` 피자 목록
  - `GET /menu/types/` 피자 타입 목록
  - `POST /menu/get_pizza_id/` 이름/사이즈로 ID 조회
- **내부 이벤트**
  - 가격/품목 변경 시 이벤트 발행(`catalog.updated`) → order-service 캐시 무효화.
- **k8s**
  - Env: `DB_HOST/PORT/NAME/USER/PASSWORD`, `CACHE_URL`(Redis 선택), `LOG_LEVEL`.
  - Probe: `/healthz`, `/livez`.
  - HPA: read 트래픽 기준 스케일.

### 3) order-service (주문)
- **책임**: 주문 생성/조회, 지점 조회, 트랜잭션.
- **데이터 논리 소유**: 단일 DB 내 `orders`, `order_detail`, `branch` 테이블 변경/스키마 관리 권한.
- **외부 노출 API**
  - `GET /order/myorder/` 내 주문 조회 (JWT 필요)
  - `POST /order/` 주문 생성 (JWT 필요)
  - `GET /order/branch/` 지점 목록
- **내부 통신**
  - 메뉴 확인 시 menu-service 호출(동기 REST) 또는 사전 캐싱.
  - 사용자 식별은 JWT 클레임 사용(별도 member 조회 불필요).
- **k8s**
  - Env: `DB_HOST/PORT/NAME/USER/PASSWORD`, `MENU_BASE_URL`, `LOG_LEVEL`.
  - Probe: `/healthz`, `/livez`.
  - HPA: write 스파이크 대비 버퍼링 전략(큐 도입 가능).

---

### 서비스 간 통신 및 계약
- **인증 전달**: 외부 요청은 Gateway에서 JWT 검증 후, 백엔드로 `X-User-Id` 등 헤더 전달(Zero-trust 원칙 유지). 또는 각 서비스가 직접 JWT 검증.
- **동기 호출**: order → menu (가격/유효성). 타임아웃/재시도/서킷브레이커 적용.
- **비동기 이벤트**(선택): NATS/Kafka/Redis Streams로 `catalog.updated`, `order.created` 발행. 사가/아웃박스 패턴 검토.
- **API 계약 관리**: OpenAPI/JSON Schema 계약 테스트(consumer-driven contracts) 도입.

### 데이터 전략 (단일 DB)
- 물리 DB는 단일 PostgreSQL 인스턴스/스키마를 공유.
- 테이블 단위 논리 소유권을 명시하고, 각 서비스는 자신의 테이블만 쓰기 권한을 가짐.
- DB 계정 분리 권장: 서비스별 최소권한 계정(예: 읽기/쓰기 테이블 범위 제한, RLS/뷰 활용 가능).
- 교차 조인은 지양. 필요 데이터는 서비스 API 호출 또는 DB 읽기(읽기 전용)로 처리.
- 공통 식별자: `member_id`, `pizza_id`, `bran_id`는 문자열 UUID 권장.

### 인증/인가
- JWT 서명키는 단일 소스(login-service)에서 관리. Gateway 또는 각 서비스에서 검증.
- 권한 모델 단순화: 초기엔 사용자 권한만. 어드민은 별도 어드민 백오피스 고려.

### 게이트웨이/라우팅
- 옵션 A: Ingress-NGINX + 서비스별 Path 기반 라우팅(`/login`, `/menu`, `/order`).
- 옵션 B: API Gateway(Kong/Traefik/Emissary/NGINX)로 인증/레이트리밋/로깅 일원화.

### 관측성/운영
- 로깅: 구조화 로그(JSON). `trace_id` 전파.
- 메트릭: Prometheus(HTTP latency, error rate, RPS). 대시보드: Grafana.
- 트레이싱: OpenTelemetry + Jaeger/Tempo.
- 알림: Alertmanager 규칙(5xx 비율, HPA 한계, DB 연결 실패).

### CI/CD 파이프라인 개요
- 빌드: 각 서비스 도커 이미지 생성(`Dockerfile` per service).
- 테스트: 유닛/통합, 계약 테스트 병행.
- 보안: SAST/Dependency scan, 이미지 서명(Cosign).
- 배포: Argo CD/GitOps 또는 CI에서 `kubectl apply`/Helm.
- 프로모션: dev → stg → prod 단계적.

### k8s 매니페스트(예시 스케치)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: login-deploy
  namespace: pizza-dev
spec:
  replicas: 2
  selector:
    matchLabels:
      app: login
  template:
    metadata:
      labels:
        app: login
    spec:
      containers:
        - name: login
          image: registry.example.com/pizza/login:1.0.0
          ports:
            - containerPort: 8000
          envFrom:
            - secretRef:
                name: login-secrets
            - configMapRef:
                name: login-config
          readinessProbe:
            httpGet:
              path: /healthz
              port: 8000
          livenessProbe:
            httpGet:
              path: /livez
              port: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: login-svc
  namespace: pizza-dev
spec:
  selector:
    app: login
  ports:
    - port: 80
      targetPort: 8000
```

### 레포 구조 제안
- 옵션 A: **멀티 레포**
  - `pizza-login/`, `pizza-menu/`, `pizza-order/` 각자 독립.
  - 장점: 경계 명확, 파이프라인 단순. 단점: 변경 원자성 저하.
- 옵션 B: **모노레포**
  - `services/login`, `services/menu`, `services/order`, `infra/`(Helm/Manifests).
  - 장점: 변경 일괄, 공용 코드 공유 용이. 단점: CI 분리 필요.

### 마이그레이션/롤아웃 계획 (DB 공유)
1. 준비
   - 서비스별 DB 최소권한 계정 생성 및 연결 문자열 Secret 구성.
   - JWT 비밀키/환경변수 준비.
2. login-service 분리
   - 인증/회원 도메인을 별도 서비스로 배포.
   - Ingress/GW에서 `/api/login` 라우팅 전환.
3. menu-service 분리
   - 메뉴 읽기 API를 별도 서비스로 배포.
   - order-service(또는 기존 모놀리식)에서 메뉴 조회를 내부 HTTP 호출로 대체.
4. order-service 분리
   - 주문/지점 API 분리. JWT 클레임으로 사용자 식별.
5. 점진적 트래픽 전환
   - 카나리/블루그린으로 경로별 트래픽 이동.
6. 모놀리식 정리
   - 기능 등가성 확인 후 기존 코드 제거.

### 데이터 마이그레이션 가이드
- 물리적 데이터 이관 없음. 현행 테이블을 그대로 사용.
- 변경 사항은 마이그레이션 스크립트로 관리(Django migrations), 배포 순서 준수.
- 서비스별 DB 권한/인덱스/제약 조건 조정만 수행.

### 위험/대응
- 분산 트랜잭션: 사가/아웃박스 패턴, 보상 트랜잭션 도입.
- 성능: 캐시(Redis), 읽기/쓰기 분리, HPA 튜닝.
- 일관성: 이벤트 중복/유실 대비 멱등 처리, 재시도 설계.

### 체크리스트
- 각 서비스에 `healthz/livez`, OpenAPI 명세, 로그/메트릭/트레이싱 적용.
- Secrets/ConfigMap, RBAC 최소권한, 네트워크 폴리시(필요 시) 설정.
- CI 파이프라인에 이미지 스캔, 취약점 기준치 게이팅.
