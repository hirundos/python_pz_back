## Kubernetes 마이크로서비스 분리 설계 (login/menu/order)

### 목표
- **도메인별 서비스 분리**: `login`, `menu`, `order` 3개 서비스로 독립 배포/스케일링.
- **공유 단일 DB 유지**: 물리 DB는 하나(PostgreSQL)로 유지하되, 테이블 논리 소유권만 분리.
- **k8s 네이티브 운영**: ConfigMap/Secret, HPA, Liveness/Readiness Probe, Service/Ingress 적용.
- **점진적 마이그레이션**: 어플리케이션만 분리, 데이터 이관 없이 진행.

### 상위 아키텍처

```
┌──────────────────────────────────────────────────────────────┐
│                        Ingress / API GW                       │
│                 (/login, /menu, /order 라우팅)               │
└───────────────┬───────────────────┬───────────────────────────┘
                │                   │
       ┌────────▼────────┐  ┌───────▼────────┐   ┌──────────────▼───────┐
       │ login-service    │  │ menu-service   │   │ order-service         │
       │ (auth, members)  │  │ (catalog)      │   │ (orders, branches)    │
       └────────┬─────────┘  └───────┬────────┘   └──────────────┬───────┘
                │                    │                           │
                └──────────────┬─────┴──────────────┬────────────┘
                               ▼                    ▼
                         ┌────────────────────────────────┐
                         │     Shared PostgreSQL (단일)   │
                         │  - member, pizza_types, pizza  │
                         │  - orders, order_detail, branch│
                         └────────────────────────────────┘
```

### 네임스페이스 및 리소스 네이밍 가이드
- Namespace: `pizza-prod`, `pizza-stg`, `pizza-dev`.
- Deploy/Service/ConfigMap/Secret: `{svc}-{env}` 패턴. 예) `login-deploy`, `menu-svc`.
- 이미지 태그: `{branch}-{shortsha}` 또는 SemVer. 예) `menu:1.2.0`.

---



### 1) login-service (인증/회원)
- **책임**: 회원 관리, 인증(JWT 발급/검증), 비밀번호 해싱
- **데이터 논리 소유**: 단일 DB 내 `member` 테이블에 대한 변경/스키마 관리 권한.
- **외부 노출 API (Ingress 경유)**
  - `POST /login/` 로그인 → JWT 발급
  - `GET /login/logout/` 로그아웃
  - `POST /login/register/` 회원가입
- **내부 제공 (서비스 간)**
  - `POST /int/auth/verify` 토큰 검증 
- **보안**
  - 비밀번호 해싱(Argon2/bcrypt).
  - JWT 서명키를 k8s Secret로 주입(`JWT_SECRET`).
- **k8s**
  - Env: `JWT_SECRET`, `DB_HOST/PORT/NAME/USER/PASSWORD`, `LOG_LEVEL`.
  - Probe: `/healthz` (readiness), `/livez` (liveness).
  - HPA: CPU/메모리 기반 오토스케일.

### 2) menu-service (카탈로그)
- **책임**: 피자 타입/상품/이미지/가격 조회. 캐시/검색 최적화.
- **데이터 논리 소유**: 단일 DB 내 `pizza_types`, `pizza` 테이블 변경/스키마 관리 권한.
- **외부 노출 API**
  - `GET /menu/` 피자 목록
  - `GET /menu/types/` 피자 타입 목록
  - `POST /menu/get_pizza_id/` 이름/사이즈로 ID 조회
- **내부 이벤트**
  - 가격/품목 변경 시 이벤트 발행(`catalog.updated`) → order-service 캐시 무효화.
- **k8s**
  - Env: `DB_HOST/PORT/NAME/USER/PASSWORD`, `CACHE_URL`(Redis 선택), `LOG_LEVEL`.
  - Probe: `/healthz`, `/livez`.
  - HPA: read 트래픽 기준 스케일.

### 3) order-service (주문)
- **책임**: 주문 생성/조회, 지점 조회, 트랜잭션.
- **데이터 논리 소유**: 단일 DB 내 `orders`, `order_detail`, `branch` 테이블 변경/스키마 관리 권한.
- **외부 노출 API**
  - `GET /order/myorder/` 내 주문 조회 (JWT 필요)
  - `POST /order/` 주문 생성 (JWT 필요)
  - `GET /order/branch/` 지점 목록
- **내부 통신**
  - 메뉴 확인 시 menu-service 호출(동기 REST) 또는 사전 캐싱.
  - 사용자 식별은 JWT 클레임 사용(별도 member 조회 불필요).
- **k8s**
  - Env: `DB_HOST/PORT/NAME/USER/PASSWORD`, `MENU_BASE_URL`, `LOG_LEVEL`.
  - Probe: `/healthz`, `/livez`.
  - HPA: write 스파이크 대비 버퍼링 전략(큐 도입 가능).

---

### 서비스 간 통신 및 계약
- **인증 전달**: 외부 요청은 Gateway에서 JWT 검증 후, 백엔드로 `X-User-Id` 등 헤더 전달(Zero-trust 원칙 유지). 또는 각 서비스가 직접 JWT 검증.
- **동기 호출**: order → menu (가격/유효성). 타임아웃/재시도/서킷브레이커 적용.
- **비동기 이벤트**(선택): NATS/Kafka/Redis Streams로 `catalog.updated`, `order.created` 발행. 사가/아웃박스 패턴 검토.
- **API 계약 관리**: OpenAPI/JSON Schema 계약 테스트(consumer-driven contracts) 도입.

### 데이터 전략 (단일 DB)
- 물리 DB는 단일 PostgreSQL 인스턴스/스키마를 공유.
- 테이블 단위 논리 소유권을 명시하고, 각 서비스는 자신의 테이블만 쓰기 권한을 가짐.
- DB 계정 분리 권장: 서비스별 최소권한 계정(예: 읽기/쓰기 테이블 범위 제한, RLS/뷰 활용 가능).
- 교차 조인은 지양. 필요 데이터는 서비스 API 호출 또는 DB 읽기(읽기 전용)로 처리.
- 공통 식별자: `member_id`, `pizza_id`, `bran_id`는 문자열 UUID 권장.

### 인증/인가
- JWT 서명키는 단일 소스(login-service)에서 관리. Gateway 또는 각 서비스에서 검증.
- 권한 모델 단순화: 초기엔 사용자 권한만. 어드민은 별도 어드민 백오피스 고려.

### 게이트웨이/라우팅
- 옵션 A: Ingress-NGINX + 서비스별 Path 기반 라우팅(`/login`, `/menu`, `/order`).
- 옵션 B: API Gateway(Kong/Traefik/Emissary/NGINX)로 인증/레이트리밋/로깅 일원화.

### 관측성/운영
- 로깅: 구조화 로그(JSON). `trace_id` 전파.
- 메트릭: Prometheus(HTTP latency, error rate, RPS). 대시보드: Grafana.
- 트레이싱: OpenTelemetry + Jaeger/Tempo.
- 알림: Alertmanager 규칙(5xx 비율, HPA 한계, DB 연결 실패).

### CI/CD 파이프라인 개요
- 빌드: 각 서비스 도커 이미지 생성(`Dockerfile` per service).
- 테스트: 유닛/통합, 계약 테스트 병행.
- 보안: SAST/Dependency scan, 이미지 서명(Cosign).
- 배포: Argo CD/GitOps 또는 CI에서 `kubectl apply`/Helm.
- 프로모션: dev → stg → prod 단계적.

### k8s 매니페스트(예시 스케치)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: login-deploy
  namespace: pizza-dev
spec:
  replicas: 2
  selector:
    matchLabels:
      app: login
  template:
    metadata:
      labels:
        app: login
    spec:
      containers:
        - name: login
          image: registry.example.com/pizza/login:1.0.0
          ports:
            - containerPort: 8000
          envFrom:
            - secretRef:
                name: login-secrets
            - configMapRef:
                name: login-config
          readinessProbe:
            httpGet:
              path: /healthz
              port: 8000
          livenessProbe:
            httpGet:
              path: /livez
              port: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: login-svc
  namespace: pizza-dev
spec:
  selector:
    app: login
  ports:
    - port: 80
      targetPort: 8000
```

### 레포 구조 제안
- 옵션 A: **멀티 레포**
  - `pizza-login/`, `pizza-menu/`, `pizza-order/` 각자 독립.
  - 장점: 경계 명확, 파이프라인 단순. 단점: 변경 원자성 저하.
- 옵션 B: **모노레포**
  - `services/login`, `services/menu`, `services/order`, `infra/`(Helm/Manifests).
  - 장점: 변경 일괄, 공용 코드 공유 용이. 단점: CI 분리 필요.

### 마이그레이션/롤아웃 계획 (DB 공유)
1. 준비
   - 서비스별 DB 최소권한 계정 생성 및 연결 문자열 Secret 구성.
   - JWT 비밀키/환경변수 준비.
2. login-service 분리
   - 인증/회원 도메인을 별도 서비스로 배포.
   - Ingress/GW에서 `/api/login` 라우팅 전환.
3. menu-service 분리
   - 메뉴 읽기 API를 별도 서비스로 배포.
   - order-service(또는 기존 모놀리식)에서 메뉴 조회를 내부 HTTP 호출로 대체.
4. order-service 분리
   - 주문/지점 API 분리. JWT 클레임으로 사용자 식별.
5. 점진적 트래픽 전환
   - 카나리/블루그린으로 경로별 트래픽 이동.
6. 모놀리식 정리
   - 기능 등가성 확인 후 기존 코드 제거.

### 데이터 마이그레이션 가이드
- 물리적 데이터 이관 없음. 현행 테이블을 그대로 사용.
- 변경 사항은 마이그레이션 스크립트로 관리(Django migrations), 배포 순서 준수.
- 서비스별 DB 권한/인덱스/제약 조건 조정만 수행.

### 위험/대응
- 분산 트랜잭션: 사가/아웃박스 패턴, 보상 트랜잭션 도입.
- 성능: 캐시(Redis), 읽기/쓰기 분리, HPA 튜닝.
- 일관성: 이벤트 중복/유실 대비 멱등 처리, 재시도 설계.

### 체크리스트
- 각 서비스에 `healthz/livez`, OpenAPI 명세, 로그/메트릭/트레이싱 적용.
- Secrets/ConfigMap, RBAC 최소권한, 네트워크 폴리시(필요 시) 설정.
- CI 파이프라인에 이미지 스캔, 취약점 기준치 게이팅.
